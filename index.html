<!doctype html>
<html lang="es" data-theme="auto">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Lector PDF â€” biblioteca, marcadores, cache, PWA</title>

<!-- PWA: manifest + color + apple tags -->
<link rel="manifest" href="manifest.webmanifest">
<meta name="theme-color" content="#0f1115" />
<link rel="apple-touch-icon" href="icons/apple-touch-icon.png">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="Lector PDF">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<style>
  :root {
    color-scheme: light dark;
    --bg: #0f1115;
    --bg-soft: #12151b;
    --panel: #171b22;
    --panel-2: #1e2430;
    --text: #e8ecf1;
    --muted: #a9b2bf;
    --accent: #6ea8fe;
    --accent-2: #9ad1ff;
    --border: #2a3140;
    --ok: #65c18c;
    --warn: #ffcc66;
    --danger: #ff7b7b;
    --shadow: 0 10px 30px rgba(0,0,0,.35);
    --radius: 14px;
    --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans";
    --line-h: 1.55;
    --font-size: 16.5px;
    --sidebar-w: 320px;
    --ease: cubic-bezier(.2,.7,.2,1);
  }
  [data-theme="light"] {
    --bg: #f7f8fb; --bg-soft: #fbfcff; --panel: #ffffff; --panel-2: #f3f5f9;
    --text: #0f172a; --muted: #4b5563; --accent: #2563eb; --accent-2: #60a5fa;
    --border: #e5e7eb; --ok: #16a34a; --warn: #d97706; --danger: #ef4444;
    --shadow: 0 10px 24px rgba(2,6,23,.06);
  }
  html, body { height: 100%; background: var(--bg); color: var(--text); }
  body { margin: 0; font-family: var(--sans); line-height: var(--line-h); font-size: var(--font-size); }
  .app { display: flex; min-height: 100vh; }

  /* Sidebar plegable con animaciÃ³n */
  aside.sidebar {
    position: sticky; top: 0; height: 100vh;
    width: var(--sidebar-w);
    transition: width 280ms var(--ease), padding 280ms var(--ease), border-color 280ms var(--ease);
    padding: 16px; background: var(--panel); border-right: 1px solid var(--border); box-shadow: var(--shadow); overflow: hidden;
  }
  aside.sidebar .inner { display: grid; grid-template-rows: auto auto 1fr; gap: 14px; height: 100%; opacity: 1; transform: translateX(0); transition: opacity 220ms var(--ease), transform 220ms var(--ease); }
  aside.sidebar.collapsed { width: 0px; padding: 16px 0; border-right-color: transparent; }
  aside.sidebar.collapsed .inner { opacity: 0; transform: translateX(-14px); pointer-events: none; }

  #reopen {
    position: fixed; top: 14px; left: 10px; z-index: 40; display: none;
    padding: 8px 10px; border-radius: 10px; border: 1px solid var(--border); background: var(--panel);
    box-shadow: var(--shadow); cursor: pointer;
  }
  .sidebar.collapsed ~ main #reopen { display: inline-flex; }
  #reopen svg { width: 18px; height: 18px; }

  .brand { font-weight: 700; letter-spacing: .2px; display: flex; align-items: center; gap: 8px; }
  .brand .dot { width: 10px; height: 10px; border-radius: 50%; background: var(--accent); display: inline-block; }

  .uploader { border: 1px dashed var(--border); border-radius: var(--radius); background: var(--panel-2); padding: 12px; }
  .uploader .row { display:flex; align-items:center; gap: 10px; flex-wrap: wrap; }
  .uploader input[type="file"] { appearance: none; border: 1px solid var(--border); border-radius: 10px; padding: 6px 10px; background: var(--panel); color: var(--text); }
  .dropzone { margin-top: 10px; padding: 12px; border: 1px dashed var(--border); border-radius: 12px; text-align: center; color: var(--muted); background: var(--bg-soft); user-select: none; }
  .dropzone.dragover { border-color: var(--accent); color: var(--accent-2); background: color-mix(in oklab, var(--panel-2) 70%, var(--accent) 30%); }

  .section-title { margin: 10px 0 6px; font-weight: 600; color: var(--muted); font-size: .9rem; text-transform: uppercase; letter-spacing: .08em; }
  .pdf-list, .bm-list { overflow: auto; min-height: 80px; border: 1px solid var(--border); border-radius: 12px; background: var(--panel-2); }
  .pdf-item { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 8px; padding: 10px 12px; border-bottom: 1px solid var(--border); cursor: pointer; }
  .pdf-item:last-child { border-bottom: 0; }
  .pdf-item.active { background: color-mix(in oklab, var(--accent) 18%, var(--panel-2) 82%); }
  .pdf-name { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  .pdf-meta { font-size: .8rem; color: var(--muted); }

  .bm-list .bm-item { display: grid; grid-template-columns: 1fr auto; align-items: center; padding: 8px 12px; border-bottom: 1px solid var(--border); }
  .bm-list .bm-item:last-child { border-bottom: 0; }
  .bm-item .bm-text { cursor: pointer; }
  .bm-actions { display:flex; gap:8px; }
  .bm-btn { border: 1px solid var(--border); background: var(--panel); color: var(--text); border-radius: 8px; padding: 4px 8px; font-size: .8rem; cursor: pointer; }
  .bm-btn:hover { border-color: var(--accent); }

  main.viewer { flex: 1; min-width: 0; display: grid; grid-template-rows: auto 1fr auto; gap: 12px; padding: 16px; position: relative; }
  .toolbar { position: sticky; top: 0; z-index: 5; display:flex; align-items:center; gap:10px; flex-wrap:wrap; padding: 10px 12px;
    background: var(--panel); border: 1px solid var(--border); border-radius: var(--radius); box-shadow: var(--shadow); }
  .toolbar .spacer { flex: 1; }
  .toolbar .muted { color: var(--muted); }
  .btn { border: 1px solid var(--border); background: linear-gradient(180deg, var(--panel-2), var(--panel)); color: var(--text);
    border-radius: 10px; padding: 8px 12px; cursor: pointer; transition: transform .06s ease; }
  .btn:hover { transform: translateY(-1px); }
  .btn.primary { border-color: color-mix(in oklab, var(--accent) 40%, var(--border) 60%); }
  .btn:disabled { opacity:.6; cursor:not-allowed; }
  .toggle, .chip { display:inline-flex; align-items:center; gap:8px; border: 1px solid var(--border); background: var(--panel-2); padding: 6px 10px; border-radius: 999px; font-size: .95rem; }
  .toggle input, .chip input { accent-color: var(--accent); }
  #out { display: grid; gap: 16px; max-width: 1100px; margin: 0 auto; }
  .page { border: 1px solid var(--border); border-radius: var(--radius); background: var(--panel); box-shadow: var(--shadow); }
  .page-header { display:flex; align-items:center; gap:10px; justify-content: space-between; padding: 10px 12px; border-bottom: 1px solid var(--border); background: var(--panel-2); border-top-left-radius: var(--radius); border-top-right-radius: var(--radius); }
  .page-header .title { font-weight: 600; }
  .page-actions { display:flex; align-items:center; gap:8px; }
  .page-body { padding: 10px 12px; }
  .page-text { list-style: none; padding-left: 0; margin: 0; font-family: var(--mono); white-space: pre-wrap; word-wrap: break-word; }
  .line { position: relative; padding: 4px 8px 4px 28px; border-radius: 8px; transition: background .15s ease; cursor: pointer; }
  .line:hover { background: color-mix(in oklab, var(--accent) 10%, var(--panel) 90%); }
  .line::before { content: attr(data-line); position: absolute; left: 8px; top: 4px; font-size: .78rem; color: var(--muted); }
  .line.bookmarked { background: color-mix(in oklab, var(--accent) 18%, var(--panel) 82%); outline: 1px solid color-mix(in oklab, var(--accent) 38%, var(--border) 62%); }
  .skeleton { height: 80px; border-radius: 10px; background: linear-gradient(90deg,
      color-mix(in oklab, var(--panel-2) 85%, var(--text) 15%) 25%,
      color-mix(in oklab, var(--panel) 85%, var(--text) 15%) 37%,
      color-mix(in oklab, var(--panel-2) 85%, var(--text) 15%) 63%);
    background-size: 400% 100%; animation: shimmer 1.25s infinite linear; }
  @keyframes shimmer { from { background-position: 0% 0; } to { background-position: 100% 0; } }
  #sentinel { height: 1px; }
  .footerInfo { text-align: center; color: var(--muted); font-size: .92rem; }

  * { scrollbar-width: thin; scrollbar-color: color-mix(in oklab, var(--text) 20%, transparent) transparent; }
  *::-webkit-scrollbar { height: 10px; width: 10px; }
  *::-webkit-scrollbar-track { background: transparent; }
  *::-webkit-scrollbar-thumb { background: color-mix(in oklab, var(--text) 20%, transparent); border-radius: 10px; }
</style>

<div class="app">
  <aside class="sidebar" id="sidebar">
    <div class="inner">
      <div class="brand"><span class="dot"></span><span>Biblioteca PDF</span></div>

      <div class="uploader">
        <div class="row">
          <input id="fileInput" type="file" accept="application/pdf" multiple />
          <button class="btn" id="btnClearLib" title="Vaciar biblioteca y cachÃ©">Vaciar</button>
        </div>
        <div class="dropzone" id="dropzone">Arrastra aquÃ­ tus PDF</div>
      </div>

      <div>
        <div class="section-title">Documentos</div>
        <div class="pdf-list" id="pdfList"></div>
      </div>

      <div>
        <div class="section-title">Marcadores</div>
        <div class="bm-list" id="bmList"></div>
      </div>
    </div>
  </aside>

  <main class="viewer">
    <button id="reopen" title="Mostrar biblioteca (atajo: [ )" aria-label="Mostrar biblioteca">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M10 6l6 6-6 6"/></svg>
    </button>

    <div class="toolbar">
      <button class="btn" id="toggleSidebar" title="Mostrar/ocultar biblioteca (atajo: [ )" aria-label="Alternar biblioteca">
        <span id="tsIcon">â˜°</span>
      </button>

      <div class="chip">Inicial:
        <input id="initialN" type="number" value="5" min="1" step="1" style="width:4.5rem;margin-left:6px">
      </div>

      <label class="toggle" title="Omitir cabecera/pie (primera y Ãºltima lÃ­nea)">
        <input type="checkbox" id="omitEdges" checked />
        <span>Omitir 1Âª y Ãºltima lÃ­nea</span>
      </label>

      <label class="toggle" title="Modo noche / dÃ­a / auto">
        <select id="themeSelect" style="background:none;border:none;color:inherit;outline:none">
          <option value="auto">Auto</option>
          <option value="dark">Noche</option>
          <option value="light">DÃ­a</option>
        </select>
      </label>

      <button class="btn primary" id="btnProcess" disabled>Procesar</button>
      <button class="btn" id="btnCopy" disabled>Copiar lo cargado</button>

      <div class="spacer"></div>
      <span class="muted" id="info">Sube PDFs en la biblioteca y elige uno.</span>
    </div>

    <div id="out"></div>
    <div id="sentinel"></div>
    <div class="footerInfo" id="footerInfo"></div>
  </main>
</div>

<script type="module">
  /* ====== pdf.js autohospedado ====== */
  import * as pdfjsLib from "./lib/pdfjs/pdf.mjs";
  pdfjsLib.GlobalWorkerOptions.workerSrc = "./lib/pdfjs/pdf.worker.mjs";

  /* ====== Service Worker (PWA) ====== */
  if ("serviceWorker" in navigator) {
    navigator.serviceWorker.register("./sw.js").catch(console.error);
  }

  /* ====== IndexedDB helpers ====== */
  const DB_NAME = "pdfReaderDB";
  const DB_VERSION = 1;
  const STORES = { documents:"documents", bookmarks:"bookmarks", pageLines:"pageLines", settings:"settings" };
  const DB = {
    db:null,
    async open(){ if(this.db) return this.db;
      this.db = await new Promise((resolve,reject)=>{
        const req = indexedDB.open(DB_NAME, DB_VERSION);
        req.onupgradeneeded = () => {
          const db = req.result;
          if(!db.objectStoreNames.contains(STORES.documents)) db.createObjectStore(STORES.documents,{keyPath:"id"});
          if(!db.objectStoreNames.contains(STORES.bookmarks)) db.createObjectStore(STORES.bookmarks,{keyPath:"id"});
          if(!db.objectStoreNames.contains(STORES.pageLines)) db.createObjectStore(STORES.pageLines,{keyPath:"key"});
          if(!db.objectStoreNames.contains(STORES.settings))  db.createObjectStore(STORES.settings,{keyPath:"key"});
        };
        req.onsuccess=()=>resolve(req.result); req.onerror=()=>reject(req.error);
      }); return this.db; },
    tx(s,mode="readonly"){ return this.db.transaction(s,mode).objectStore(s); },
    async get(s,k){ await this.open(); return new Promise((res,rej)=>{ const q=this.tx(s).get(k); q.onsuccess=()=>res(q.result||null); q.onerror=()=>rej(q.error); }); },
    async set(s,v){ await this.open(); return new Promise((res,rej)=>{ const q=this.tx(s,"readwrite").put(v); q.onsuccess=()=>res(true); q.onerror=()=>rej(q.error); }); },
    async del(s,k){ await this.open(); return new Promise((res,rej)=>{ const q=this.tx(s,"readwrite").delete(k); q.onsuccess=()=>res(true); q.onerror=()=>rej(q.error); }); },
    async getAll(s){ await this.open(); return new Promise((res,rej)=>{ const q=this.tx(s).getAll(); q.onsuccess=()=>res(q.result||[]); q.onerror=()=>rej(q.error); }); },
    async clear(s){ await this.open(); return new Promise((res,rej)=>{ const q=this.tx(s,"readwrite").clear(); q.onsuccess=()=>res(true); q.onerror=()=>rej(q.error); }); },
  };

  /* ====== Estado / refs / util ====== */
  const state = {
    docs: [], currentId: null, pdf: null, totalPages: 0, loadedPages: 0,
    isLoading:false, observer:null, pageLinesCache:new Map(), sidebarCollapsed:false
  };

  const $ = (s,p=document)=>p.querySelector(s);
  const el=(t,props={},children=[])=>{ const n=Object.assign(document.createElement(t),props); for(const c of [].concat(children)) n.append(c); return n; };

  const sidebar     = $("#sidebar");
  const btnToggleSB = $("#toggleSidebar");
  const reopenBtn   = $("#reopen");
  const tsIcon      = $("#tsIcon");
  const fileInput   = $("#fileInput");
  const dropzone    = $("#dropzone");
  const pdfList     = $("#pdfList");
  const bmList      = $("#bmList");
  const btnClearLib = $("#btnClearLib");
  const initialNInp = $("#initialN");
  const omitEdgesInp= $("#omitEdges");
  const themeSelect = $("#themeSelect");
  const btnProcess  = $("#btnProcess");
  const btnCopy     = $("#btnCopy");
  const info        = $("#info");
  const out         = $("#out");
  const sentinel    = $("#sentinel");
  const footerInfo  = $("#footerInfo");

  /* ====== Preferencias ====== */
  const savedTheme = localStorage.getItem("pdfTheme") || "auto";
  themeSelect.value = savedTheme; setTheme(savedTheme);
  themeSelect.addEventListener("change", ()=>{ setTheme(themeSelect.value); localStorage.setItem("pdfTheme", themeSelect.value); });
  function setTheme(mode){ if(mode==="auto"){ const dark=matchMedia("(prefers-color-scheme: dark)").matches;
      document.documentElement.setAttribute("data-theme", dark?"dark":"light");
    } else { document.documentElement.setAttribute("data-theme", mode); } }

  const savedCollapsed = localStorage.getItem("pdfSidebarCollapsed");
  if (savedCollapsed === "1") collapseSidebar(true);
  btnToggleSB.addEventListener("click", toggleSidebar);
  reopenBtn.addEventListener("click", ()=>{ if(state.sidebarCollapsed) toggleSidebar(); });
  document.addEventListener("keydown",(e)=>{ if(e.key==="["){ e.preventDefault(); toggleSidebar(); }});
  function toggleSidebar(){ state.sidebarCollapsed?expandSidebar():collapseSidebar(); }
  function collapseSidebar(){ state.sidebarCollapsed=true; sidebar.classList.add("collapsed"); tsIcon.textContent="â®ž"; localStorage.setItem("pdfSidebarCollapsed","1"); }
  function expandSidebar(){ state.sidebarCollapsed=false; sidebar.classList.remove("collapsed"); tsIcon.textContent="â˜°"; localStorage.setItem("pdfSidebarCollapsed","0"); }

  const savedOmit = localStorage.getItem("pdfOmitEdges"); if(savedOmit!=null) omitEdgesInp.checked = savedOmit==="1";
  omitEdgesInp.addEventListener("change", ()=> localStorage.setItem("pdfOmitEdges", omitEdgesInp.checked?"1":"0"));
  const savedInitial= localStorage.getItem("pdfInitialN"); if(savedInitial) initialNInp.value = savedInitial;
  initialNInp.addEventListener("change", ()=> localStorage.setItem("pdfInitialN", String(initialNInp.value||5)));

  /* ====== Cargar biblioteca desde IndexedDB ====== */
  await DB.open();
  await loadDocsFromDB();

  async function loadDocsFromDB(){
    const docs = await DB.getAll("documents");
    state.docs = await Promise.all(docs.map(async rec => {
      const bm = await DB.get("bookmarks", rec.id);
      return {
        id: rec.id, name: rec.name, size: rec.size, bytes: null,
        bookmarks: bm ? deserializeBookmarks(bm) : { pages:new Set(), lines:new Map() },
        cached: true
      };
    }));
    renderDocList();
  }

  function renderDocList(){
    pdfList.innerHTML = "";
    if (!state.docs.length){
      pdfList.append(el("div",{className:"pdf-item"},[
        el("div",{className:"pdf-name",textContent:"No hay documentos"}),
        el("div",{className:"pdf-meta",textContent:""})
      ]));
      return;
    }
    for(const d of state.docs){
      const item = el("div",{className:"pdf-item"+(d.id===state.currentId?" active":"")});
      const name = el("div",{className:"pdf-name",textContent:d.name});
      const meta = el("div",{className:"pdf-meta",textContent:`${fmtSize(d.size)} â€¢ cachÃ©`});
      item.append(name,meta);
      item.addEventListener("click",()=>selectDoc(d.id));
      pdfList.append(item);
    }
  }

  // Subir/arrastrar
  fileInput.addEventListener("change",(e)=>{ if(!e.target.files?.length) return; addFiles([...e.target.files]); });
  ["dragenter","dragover"].forEach(ev=>dropzone.addEventListener(ev,(e)=>{ e.preventDefault(); dropzone.classList.add("dragover"); }));
  ["dragleave","drop"].forEach(ev=>dropzone.addEventListener(ev,(e)=>{ e.preventDefault(); dropzone.classList.remove("dragover"); }));
  dropzone.addEventListener("drop",(e)=>{ const files=[...(e.dataTransfer?.files||[])].filter(f=>f.type==="application/pdf"); addFiles(files); });

  btnClearLib.addEventListener("click", async ()=>{
    await DB.clear("pageLines"); await DB.clear("bookmarks"); await DB.clear("documents");
    state.docs=[]; state.currentId=null; renderDocList(); resetViewer(); bmList.innerHTML="";
    info.textContent="Biblioteca y cachÃ© vaciadas."; btnProcess.disabled=true;
  });

  async function addFiles(files){
    for(const file of files){
      const bytes = await file.arrayBuffer();
      const id = await computeDocId(file.name, bytes);
      const size = bytes.byteLength;

      const exists = await DB.get("documents", id);
      if (!exists){
        try {
          await DB.set("documents", { id, name:file.name, size, bytes:new Blob([bytes],{type:"application/pdf"}), addedAt:Date.now() });
        } catch (e) { console.warn("Guardar en DB fallÃ³:", e); }
      }
      let doc = state.docs.find(d=>d.id===id);
      if (!doc){
        doc = { id, name:file.name, size, bytes, bookmarks:{pages:new Set(), lines:new Map()}, cached:true };
        state.docs.push(doc);
      } else {
        doc.name=file.name; doc.size=size;
      }
    }
    renderDocList();
    info.textContent="PDF(s) aÃ±adido(s). Elige uno para leer.";
    if(!state.currentId && state.docs.length){ selectDoc(state.docs[0].id); }
  }

async function selectDoc(id){
  state.currentId = id;
  state.pageLinesCache.clear();
  renderDocList();
  resetViewer();
  btnProcess.disabled = !getCurrentDoc();
  if(!getCurrentDoc()) return;

  const doc = getCurrentDoc();
  if (!doc.bytes){
    const rec = await DB.get("documents", doc.id);
    if (!rec || !rec.bytes){ info.textContent="No se encontraron los datos en cachÃ©."; return; }
    doc.bytes = await rec.bytes.arrayBuffer();
    doc.size = rec.size||doc.size;
    doc.cached=true;
  }

  const bm = await DB.get("bookmarks", doc.id);
  if (bm) doc.bookmarks = deserializeBookmarks(bm);

  info.textContent = `Cargando ${doc.name}â€¦`;

  state.pdf = await pdfjsLib.getDocument({ 
    data: new Uint8Array(doc.bytes),     // ðŸ‘ˆ aquÃ­ ya pasamos Uint8Array directo
    cMapUrl: "./lib/pdfjs/cmaps/",
    cMapPacked: true,
    standardFontDataUrl: "./lib/pdfjs/standard_fonts/"
  }).promise;

  state.totalPages = state.pdf.numPages;

  // ðŸ‘‡ en vez de esperar a que el usuario pulse, procesamos ya
  btnProcess.click();
}


  function getCurrentDoc(){ return state.docs.find(d=>d.id===state.currentId)||null; }

  // Viewer / extracciÃ³n con cachÃ©
  btnProcess.addEventListener("click", async ()=>{
    if (!getCurrentDoc()) return;
    out.innerHTML=""; state.loadedPages=0; state.pageLinesCache.clear();
    info.textContent="Procesandoâ€¦";
    const initial = clamp(parseInt(initialNInp.value||"5",10),1,state.totalPages);
    for(let i=1;i<=initial;i++){ await appendPage(i); }
    ensureObserver(); refreshFooter();
    info.textContent = `Listo. Mostradas ${state.loadedPages}/${state.totalPages}.`;
  });

  btnCopy.addEventListener("click", async ()=>{
    const chunks=[];
    for(let i=1;i<=state.loadedPages;i++){
      const lines = state.pageLinesCache.get(i); if(!lines) continue;
      chunks.push(`--- PÃGINA ${i} DE ${state.totalPages} ---\n`+lines.join("\n"));
    }
    if(!chunks.length) return;
    await navigator.clipboard.writeText(chunks.join("\n\n"));
    info.textContent="Texto copiado (pÃ¡ginas cargadas).";
  });

  omitEdgesInp.addEventListener("change", async ()=>{
    if(!getCurrentDoc() || !state.pdf) return;
    info.textContent="Reformateandoâ€¦";
    for(let i=1;i<=state.loadedPages;i++){
      const container = document.querySelector(`#page-${i} .page-body .page-text`); if(!container) continue;
      const lines = await getLinesWithEdgesPolicy(getCurrentDoc().id,i);
      renderLinesInto(container,i,lines); state.pageLinesCache.set(i,lines);
    }
    info.textContent=`Listo. Mostradas ${state.loadedPages}/${state.totalPages}.`;
    renderBmList();
  });

  function ensureObserver(){
    if(state.observer) state.observer.disconnect();
    state.observer = new IntersectionObserver(async (entries)=>{
      for(const entry of entries){
        if(!entry.isIntersecting) continue;
        const next = state.loadedPages+1;
        if(state.pdf && next<=state.totalPages && !state.isLoading){ await appendPage(next); refreshFooter(); }
      }
    },{ root:null, rootMargin:"800px", threshold:0 });
    state.observer.observe(sentinel);
  }

  function resetViewer(){
    out.innerHTML=""; info.textContent="Elige un documento en la biblioteca."; footerInfo.textContent="";
    state.pdf=null; state.totalPages=0; state.loadedPages=0; state.isLoading=false; state.pageLinesCache.clear();
    if(state.observer){ state.observer.disconnect(); state.observer=null; }
    btnCopy.disabled=true;
  }

  async function appendPage(pageIndex){
    if(state.isLoading) return; state.isLoading=true;

    const card = el("div",{className:"page",id:`page-${pageIndex}`,"data-page":pageIndex});
    const header = el("div",{className:"page-header"});
    const title  = el("div",{className:"title",textContent:`PÃ¡gina ${pageIndex} de ${state.totalPages}`});
    const actions= el("div",{className:"page-actions"});
    const bmBtn  = el("button",{className:"btn",textContent:"â˜† Marcar pÃ¡gina",title:"Marcar/Desmarcar esta pÃ¡gina"});
    actions.append(bmBtn); header.append(title,actions);
    const body = el("div",{className:"page-body"});
    const list = el("ol",{className:"page-text"});
    list.append(el("div",{className:"skeleton"})); body.append(list); card.append(header,body); out.append(card);

    syncPageBmButton(pageIndex,bmBtn);
    bmBtn.addEventListener("click", async ()=>{
      togglePageBookmark(pageIndex); syncPageBmButton(pageIndex,bmBtn); renderBmList(); await saveBookmarks(getCurrentDoc());
    });

    try {
      const doc = getCurrentDoc();
      const lines = await getLinesWithEdgesPolicy(doc.id,pageIndex);
      renderLinesInto(list,pageIndex,lines); state.pageLinesCache.set(pageIndex,lines);
    } catch(e){
      console.error(e);
      list.innerHTML=""; list.append(el("li",{className:"line",textContent:"(Error extrayendo texto de esta pÃ¡gina)"}));
    } finally {
      state.loadedPages = Math.max(state.loadedPages,pageIndex);
      state.isLoading=false; btnCopy.disabled = state.loadedPages===0;
      info.textContent=`Mostradas ${state.loadedPages}/${state.totalPages}.`;
    }
  }

  // LÃ­neas con polÃ­tica de bordes (cachÃ© en DB)
  async function getLinesWithEdgesPolicy(docId,page){
    let raw = await getCachedRawLines(docId,page);
    if(!raw){
      const p = await state.pdf.getPage(page);
      const content = await p.getTextContent();
      raw = reconstructLines(content.items);
      await setCachedRawLines(docId,page,raw);
    }
    const omit = omitEdgesInp.checked;
    const lines = omit ? raw.slice(1,-1) : raw;
    return lines.length ? lines : ["(Sin texto extraÃ­ble en esta pÃ¡gina)"];
  }

  async function getCachedRawLines(docId,page){ const key=`${docId}|${page}`; const rec = await DB.get("pageLines",key); return rec?.lines||null; }
  async function setCachedRawLines(docId,page,lines){ const key=`${docId}|${page}`; try { await DB.set("pageLines",{key,id:docId,page,lines,createdAt:Date.now()}); } catch(e){ console.warn("Cache lÃ­neas fallÃ³:",e); } }

  function renderLinesInto(container,pageIndex,lines){
    container.innerHTML="";
    const doc = getCurrentDoc();
    const lineSet = doc.bookmarks.lines.get(pageIndex) || new Set();
    lines.forEach((txt,idx)=>{
      const li = el("li",{className:"line",textContent:txt,"data-line":String(idx+1)});
      if(lineSet.has(idx+1)) li.classList.add("bookmarked");
      li.addEventListener("click", async ()=>{
        toggleLineBookmark(pageIndex,idx+1); li.classList.toggle("bookmarked");
        renderBmList(); await saveBookmarks(getCurrentDoc());
      });
      container.append(li);
    });
  }

  // Marcadores persistentes
  function togglePageBookmark(page){
    const doc=getCurrentDoc(); if(!doc) return;
    if(doc.bookmarks.pages.has(page)) doc.bookmarks.pages.delete(page); else doc.bookmarks.pages.add(page);
  }
  function toggleLineBookmark(page,line){
    const doc=getCurrentDoc(); if(!doc) return;
    const set = doc.bookmarks.lines.get(page)||new Set();
    if(set.has(line)) set.delete(line); else set.add(line);
    if(set.size) doc.bookmarks.lines.set(page,set); else doc.bookmarks.lines.delete(page);
  }
  function syncPageBmButton(page,btn){ const doc=getCurrentDoc(); const marked=doc?.bookmarks.pages.has(page);
    btn.textContent = marked ? "â˜… PÃ¡gina marcada" : "â˜† Marcar pÃ¡gina"; btn.classList.toggle("primary",!!marked);
  }
  function renderBmList(){
    const doc=getCurrentDoc(); bmList.innerHTML=""; if(!doc) return;
    const items=[];
    [...doc.bookmarks.pages].sort((a,b)=>a-b).forEach(p=>items.push({label:`PÃ¡gina ${p} (completa)`,page:p,line:null,type:"page"}));
    [...doc.bookmarks.lines.entries()].forEach(([p,set])=>{ [...set].sort((a,b)=>a-b).forEach(l=>items.push({label:`PÃ¡g. ${p} Â· lÃ­nea ${l}`,page:p,line:l,type:"line"})); });
    if(!items.length){ bmList.append(el("div",{className:"bm-item"},[el("div",{className:"bm-text",textContent:"Sin marcadores"})])); return; }
    items.sort((a,b)=>a.page-b.page|| (a.line||0)-(b.line||0));
    for(const it of items){
      const row=el("div",{className:"bm-item"});
      const txt=el("div",{className:"bm-text",textContent:it.label,title:"Ir al marcador"});
      const actions=el("div",{className:"bm-actions"});
      const btnGo=el("button",{className:"bm-btn",textContent:"Ir"});
      const btnDel=el("button",{className:"bm-btn",textContent:"Quitar"});
      btnGo.addEventListener("click",()=>scrollToMarker(it.page,it.line));
      btnDel.addEventListener("click", async ()=>{
        if(it.type==="page"){ togglePageBookmark(it.page); const b=document.querySelector(`#page-${it.page} .page-header .page-actions .btn`); if(b) syncPageBmButton(it.page,b); }
        else { toggleLineBookmark(it.page,it.line); const li=document.querySelector(`#page-${it.page} .line[data-line="${it.line}"]`); li?.classList.remove("bookmarked"); }
        renderBmList(); await saveBookmarks(getCurrentDoc());
      });
      actions.append(btnGo,btnDel); row.append(txt,actions); bmList.append(row);
    }
  }
  function scrollToMarker(page,line){
    const pageEl=document.querySelector(`#page-${page}`); if(!pageEl) return;
    pageEl.scrollIntoView({behavior:"smooth",block:"start"});
    if(line!=null){ setTimeout(()=>{ const lineEl=document.querySelector(`#page-${page} .line[data-line="${line}"]`);
      if(lineEl){ lineEl.scrollIntoView({behavior:"smooth",block:"center"});
        lineEl.animate([{backgroundColor:"transparent"},{backgroundColor:"rgba(255,215,0,.22)"},{backgroundColor:"transparent"}],{duration:1200}); } },300);
    }
  }

  async function saveBookmarks(doc){ try{ await DB.set("bookmarks", serializeBookmarks(doc.id,doc.bookmarks)); } catch(e){ console.warn("Guardar marcadores fallÃ³:",e); } }
  function serializeBookmarks(id,bm){ const pages=[...bm.pages].sort((a,b)=>a-b); const linesObj={}; for(const [p,set] of bm.lines.entries()){ const arr=[...set].sort((a,b)=>a-b); if(arr.length) linesObj[p]=arr; } return {id,pages,lines:linesObj}; }
  function deserializeBookmarks(rec){ const pages=new Set(rec.pages||[]); const lines=new Map(); const obj=rec.lines||{}; for(const k of Object.keys(obj)) lines.set(Number(k), new Set(obj[k])); return {pages,lines}; }

  // ReconstrucciÃ³n de lÃ­neas (Y/X)
  function reconstructLines(items,{skipEmptyEdge=true}={}){
    const lines=new Map();
    for(const it of items){ if(!it.str) continue; const [, , , , x, y]=it.transform; const yKey=Math.round(y);
      if(!lines.has(yKey)) lines.set(yKey,[]); lines.get(yKey).push({x,str:it.str}); }
    const ys=[...lines.keys()].sort((a,b)=>b-a);
    const textLines=ys.map(y=> lines.get(y).sort((a,b)=>a.x-b.x).map(t=>t.str.trim()).join(" ").replace(/[ \t]+/g," ").trim());
    let result=textLines.filter(l=>l.length);
    if(skipEmptyEdge){ while(result[0]?.trim()==="") result.shift(); while(result[result.length-1]?.trim()==="") result.pop(); }
    return result;
  }

  // MiscelÃ¡nea
  function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }
  function refreshFooter(){ if(!state.totalPages){ footerInfo.textContent=""; return; }
    footerInfo.textContent = state.loadedPages>=state.totalPages ? "Has llegado al final del documento." : "DesplÃ¡zate para cargar mÃ¡s pÃ¡ginasâ€¦"; }
  function fmtSize(bytes){ if(bytes==null) return ""; const u=["B","KB","MB","GB"]; let i=0,n=bytes; while(n>=1024 && i<u.length-1){ n/=1024; i++; } return `${n.toFixed(n<10&&i>0?1:0)} ${u[i]}`; }
  async function computeDocId(name,bytes){
    if(crypto?.subtle?.digest){ const hash=await crypto.subtle.digest("SHA-256",bytes);
      return [...new Uint8Array(hash)].map(b=>b.toString(16).padStart(2,"0")).join(""); }
    return `${name}|${bytes.byteLength}|${Date.now()}|${Math.random().toString(36).slice(2)}`;
  }
</script>
</html>
